# Часть 4. Сети tcp/ip

---

## Какие из приведённых адресов могут быть использованы в качестве IP-адресов сетевого интерфейса для узлов Интернета? Для синтаксически правильных адресов определите их класс: А, В, С, D или Е.</br> Варианты адресов:</br>а) 123.1.223.5;</br>б) 225.0.0.1;</br>в) 194.87.45.255;</br>г) 10.124.251.252;</br>д) 125.24.255.255;</br>е) 17.213.355.205;</br>ж) 179.12.255.255;</br>з) 127.0.23.55;</br>и) 1.0.0.13;</br>к) 124.1.1.1;</br>л) 192.134.216.255;</br>м) 293.236.254.11;</br>н) 13.13.13.13.

Ответ а), д), и), к), н)

**а) 123.1.223.5**  
Допустимый адрес. Относится к классу A (диапазон: 1.0.0.0–126.255.255.255). Первый октет (123) находится в пределах допустимого
для класса A.

**д) 125.24.255.255**  
Допустимый адрес. Также относится к классу A, так как первый октет (125) входит в диапазон 1–126.

**и) 1.0.0.13**  
Допустимый адрес. Класс A. Первый октет (1) находится в допустимом диапазоне.

**к) 124.1.1.1**  
Допустимый адрес. Класс A. Первый октет (124) входит в диапазон 1–126.

**н) 13.13.13.13**  
Допустимый адрес. Класс A. Первый октет (13) находится в допустимом диапазоне.

### Почему другие варианты не подходят
**б) 225.0.0.1**  
Недопустим для обычных сетевых интерфейсов. Относится к классу D (224.0.0.0–239.255.255.255), который зарезервирован для
многоадресной рассылки (multicast).

**в) 194.87.45.255**  
Недопустим. Относится к классу C (192.0.0.0–223.255.255.255), но последний октет (255) является широковещательным адресом
для сети, и его нельзя присвоить узлу.

**г) 10.124.251.252**  
Недопустим для Интернета. Это частный адрес из диапазона класса A (10.0.0.0/8), используемый в локальных сетях.

**е) 17.213.355.205**  
Недопустим. Третий октет (355) выходит за диапазон 0–255, что нарушает правила записи IP-адресов.

**ж) 179.12.255.255**  
Недопустим. Относится к классу B (128.0.0.0–191.255.255.255), но последний октет (255) является широковещательным адресом
для сети.

**з) 127.0.23.55**  
Недопустим для Интернета. Диапазон 127.0.0.0/8 зарезервирован для loopback (локальной отладки).

**л) 192.134.216.255**  
Недопустим. Относится к классу C (192.0.0.0–223.255.255.255), но последний октет (255) является широковещательным адресом
для сети.

**м) 293.236.254.11**  
Недопустим. Первый октет (293) выходит за допустимые пределы для всех классов IPv4 (максимум — 255).

---

## 2. Пусть IP-адрес некоторого узла подсети равен 108.5.18.167, а значение маски для этой подсети — 255.255.255.240. Определите номер подсети. Какое максимальное число сетевых интерфейсов может быть в этой подсети?

### 1. Определение номера подсети
Чтобы найти номер подсети, нужно выполнить **побитовое И** между IP‑адресом и маской.
**Дано:**
- IP‑адрес: `108.5.18.167`
- Маска: `255.255.255.240`

**Шаг 1.** Переведём последний октет в двоичный вид:
- IP (`167`): `10100111`
- Маска (`240`): `11110000`

**Шаг 2.** Выполним побитовое И:
```
  10100111 (167)
& 11110000 (240)
  ────────
  10100000 (160)
```

**Шаг 3.** Собираем полный адрес подсети:
- Первые три октета совпадают (маска `255` → берём как есть).
- Последний октет: `160`.

**Номер подсети:** `108.5.18.160`

### 2. Максимальное число сетевых интерфейсов
**Шаг 1.** Определим количество бит для хостов. 

Маска `255.255.255.240` в двоичном виде: `11111111.11111111.11111111.11110000` → **4 бита** отведены под хосты (нули в маске).

**Шаг 2.** Вычислим количество адресов.

2^4 = 16 адресов.

**Шаг 3.** Учтем ограничения:
- Один адрес — номер подсети (`108.5.18.160`). Это адрес, где все биты хостовой части — нули. Последний октет: 10100000 в двоичном
- Один адрес — широковещательный (`108.5.18.175`). Это адрес, где все биты хостовой части — единицы. Последний октет: 10101111 в двоичном.

**Итого доступных интерфейсов:**

Всего адресов в подсети: 16.

Нельзя использовать:
- 1 адрес (номер подсети),
- 1 адрес (широковещательный).

16 - 2 = 14.

---

## 3. Какое максимальное количество подсетей теоретически можно организовать, если в вашем распоряжении имеется сеть класса С? Какое значение должна при этом иметь маска? При ответе не принимайте во внимание двухточечные соединения.

Ответ:
- **Максимальное число подсетей:** 64.
- **Требуемая маска:** `255.255.255.252` (или `/30` в CIDR‑нотации).

**Что такое сеть класса C?**
- Диапазон: от `192.0.0.0` до `223.255.255.255`.
- Стандартная маска: `255.255.255.0` (`/24`), то есть:
    - **24 бита** — сетевая часть (фиксирована);
    - **8 бит** — хостовая часть (можно «забирать» под подсеть).

**Как делить на подсети?**
- Чтобы создать подсети, «забираем» биты из хостовой части и отдаём их под номер подсети.
- В классе C у нас **8 бит** для хостов. Чтобы в каждой подсети было хотя бы **2 адреса для устройств**, нужно оставить
минимум **2 бита на хосты** (тогда 2^2 - 2 = 2 полезных адреса).
- Значит, под номер подсети можно отдать **6 бит** (8 - 2 = 6).

**Почему максимум 64 подсети?**
- Если взять **6 бит** под номер подсети:
    - Число подсетей: 2^6 = 64.
    - Остаётся **2 бита** на хосты: 2^2 - 2 = 2 адреса на подсеть (минус номер сети и broadcast).
- Взять 7 бит под подсети нельзя: останется 1 бит на хосты → 2^1 - 2 = 0 адресов (бесполезно).


**Какая маска?**
- Было: `/24` (24 бита сети).
- Добавляем 6 бит под подсети: 24 + 6 = 30 бит сети.
- Маска: `255.255.255.252` (`/30`).
- Проверка:
    - Последний октет маски (`252`) в двоичном виде: `11111100` → 6 единиц (добавили 6 бит к сети) и 2 нуля (осталось на хосты).

**Почему не `/26`?**
- При `/26` мы «забираем» только 2 бита из хостовой части (26 - 24 = 2).
- Тогда:
    - Подсетей: 2^2 = 4 (намного меньше 64).
    - Хостов на подсеть: 2^6 - 2 = 62 (много, но число подсетей мало).
- `/30` даёт максимум подсетей при минимуме хостов.

---

## 4. Пусть вам ничего не известно об узлах, кроме их DNS-имен:</br> w1.piter.ru, www.msk.ru и www.piter.ru, echo.msk.ru.</br> Что вы можете сказать о том, насколько близко территориально находятся они относительно друг друга?</br> Варианты ответов:</br> а) узел www.msk.ru территориально ближе к echo.msk.ru, чем к w1.piter.ru;</br> б) узел www.msk.ru расположен ближе к www.piter.ru, чем к echo.msk.ru;</br> в) узел w1.piter.ru территориально ближе к www.piter.ru, чем к www.msk.ru;</br> г) ничего определённого.

Ответ г)

DNS‑имя (например, `www.msk.ru` или `w1.piter.ru`) **не содержит информации о физическом местоположении узла**.

- `msk.ru` — намекает на Москву (`msk` = Москва).
- `piter.ru` — намекает на Санкт‑Петербург (`piter` = Питер).

Но это **только семантика** (смысловая подсказка для человека), а не технический параметр.

**Серверы могут быть размещены где угодно**
- Домен `msk.ru` может физически находиться:
    - в Москве,
    - в другом городе России,
    - даже за границей (например, на хостинге в Германии).
- То же самое с `piter.ru`.

**DNS не привязан к географии**
- DNS‑имя — это просто «удобное имя» для IP‑адреса.
- IP‑адрес тоже **не гарантирует** местоположение (из‑за VPN, прокси, CDN, облачных сервисов).

**Примеры обмана ожиданий**
- Сайт `example.msk.ru` может работать на сервере в Сибири.
- Два сайта с `piter.ru` могут находиться в разных странах, если их хостят международные провайдеры.

---

## 5. Пусть вам ничего не известно о структуре сети, но в вашем распоряжении имеется следующая таблица соответствия IP-адресов и DNS-имен нескольких узлов сети:

| IP-адрес узла | 123.1.0.01 | 123.1.0.02 | 123.1.0.03 | 123.1.0.04 | ? | ? |
| --- | --- | --- | --- | --- | --- | --- |
| DNS-имя узла | w1.mgu.ru | w2.mgu.ru | w3.mgu.ru | w4.mgu.ru | w5.mgu.ru | w6.mgu.ru |

### Что вы можете сказать об IP-адресах узлов, имеющих DNS-имена w5.mgu.ru и w6.mgu.ru?

Между DNS-именами и IP-адресами в общем случае нет связи, поэтому ничего определенного сказать нельзя.

**Что видно из таблицы**
- Все известные узлы (`w1`–`w4`) имеют IP‑адреса в формате `123.1.0.XX`, где `XX`—порядковый номер (`01`, `02`, `03`, `04`).
- Все DNS‑имена принадлежат домену `mgu.ru` и следуют шаблону `w<номер>.mgu.ru`.

**Логичное предположение**
- Если нумерация IP‑адресов последовательная, то:
    - `w5.mgu.ru` → скорее всего, `123.1.0.05`;
    - `w6.mgu.ru` → скорее всего, `123.1.0.06`.
- Это соответствует шаблону: `123.1.0.<номер_узла>`.

**Почему нельзя утверждать наверняка**
- В таблице есть **пропуски** (знаки `?`), значит:
    - Возможно, адреса назначаются не строго по порядку (например, `w5` может иметь `123.1.0.10`).
    - Могут быть зарезервированные адреса или иная логика распределения.
- Нет информации о **маске подсети** или правилах адресации в этой сети.

**Что точно известно**
- Узлы `w5` и `w6` принадлежат той же сети (`123.1.0.0/24`), что и `w1`–`w4`, так как:
    - Первые три октета (`123.1.0`) совпадают.
    - DNS‑имена в одном домене (`mgu.ru`), что обычно указывает на единую инфраструктуру.

---

## 6. Какая запись из следующих эквивалентна значению маски /29</br> (выберите вариант ответа):</br> а) 255.255.2.9;</br> б) 255.255.255.29;</br> в) 255.255.255.248;</br> г) 255.255.255.229.

Ответ в)

Маска `/29` означает, что в двоичном представлении маски **29 первых битов — единицы**, а остальные (32 − 29 = 3) — нули.

**Переводим `/29` в двоичный вид:**
- 29 единиц: `11111111 11111111 11111111 11111000` (разбили на октеты для наглядности).
- Последние 3 бита — нули.

**Разбиваем на октеты и переводим в десятичный вид:**
- Первый октет: `11111111` = 255.
- Второй октет: `11111111` = 255.
- Третий октет: `11111111` = 255.
- Четвёртый октет: `11111000` = 248 (так как 128 + 64 + 32 + 16 + 8 = 248). Как это работает:</br>
  Разберём, почему двоичное число `11111000` равно **248** в десятичной системе.</br>
  В двоичной системе каждая позиция (бит) — это степень двойки, начиная **справа** (от младшего бита). Значение бита (`0` или `1`)
  показывает, *берём* ли мы эту степень в сумму.
  ### Шаг 1. Пронумеруем биты справа налево (начиная с 0)
  ```
  1  1  1  1  1  0  0  0
  ↑  ↑  ↑  ↑  ↑  ↑  ↑  ↑
  7  6  5  4  3  2  1  0
  ```
    - Позиция 0 (самый правый бит) → 2^0 = 1
    - Позиция 1 → 2^1 = 2
    - Позиция 2 → 2^2 = 4
    - ...
    - Позиция 7 (самый левый бит) → 2^7 = 128
  ### Шаг 2. Смотрим, где стоят единицы
  В числе `11111000` единицы — на позициях **7, 6, 5, 4, 3** (слева направо).  </br>
  Значит, берём соответствующие степени двойки:</br>
    - 2^7 = 128
    - 2^6 = 64
    - 2^5 = 32
    - 2^4 = 16
    - 2^3 = 8
  ### Шаг 3. Складываем
  128 + 64 + 32 + 16 + 8 = 248
  ### Почему нули не учитываем?
  Нули означают: «эту степень двойки **не берём**». В нашем случае нули на позициях **2, 1, 0**, поэтому:
    - 2^2 = 4 → не берём,
    - 2^1 = 2 → не берём,
    - 2^0 = 1 → не берём.
  ### Итог
  `11111000₂ = 248₁₀`, потому что:</br>
  128\ (2^7) + 64\ (2^6) + 32\ (2^5) + 16\ (2^4) + 8\ (2^3) = 248.

**Получаем маску:** `255.255.255.248`.


### Почему не другие варианты?
- **а) 255.255.2.9** — явно неверно: октеты `2` и `9` не соответствуют шаблону маски (должны быть либо 255, либо число с
«границей» из единиц и нулей).
- **б) 255.255.255.29** — неверно: `29` в последнем октете (`00011101` в двоичном) не даёт 29 единичных битов в маске.
- **г) 255.255.255.229** — неверно: `229` (`11100101` в двоичном) тоже не соответствует 29 единицам подряд.

---

## 7. Могут ли для двухточечной связи быть назначены адреса 197.220.12.9/31 и 197.220.12.10/31?

Ответ: Да, адреса `197.220.12.9/31` и `197.220.12.10/31` **могут быть назначены** для двухточечной (point‑to‑point) связи.

**Что значит `/31`?**
- Маска `/31` означает, что в IP‑адресе **31 бит отведён под сеть**, а **1 бит — под хосты**.
- В двоичном виде маска: `11111111.11111111.11111111.11111110` (31 единица + 1 ноль).
- Это даёт **всего 2 комбинации** для хостов:
  - `...0` (ноль в последнем бите),
  - `...1` (единица в последнем бите).

**Как это работает для двух устройств**
- В двухточечном соединении **ровно два узла** (например, два маршрутизатора, соединённых кабелем).
- Им достаточно **двух адресов**, что идеально ложится на схему `/31`:
  - Узел 1: `197.220.12.9` → в двоичном последний бит `1` (`...1001`).
  - Узел 2: `197.220.12.10` → в двоичном последний бит `0` (`...1010`).

**Почему это разрешено?**
- Стандарт **RFC 3021** («Using 31‑Bit Prefixes on IPv4 Point‑to‑Point Links») специально разрешает использовать `/31` для двухточечных связей.
- Обычно в подсети «забирают» 2 адреса:
  - один — на адрес сети (все нули в хостовой части),
  - один — на широковещательный адрес (все единицы в хостовой части).
- Но в `/31` это **не нужно**:
  - Два оставшихся адреса напрямую назначаются двум узлам.
  - Широковещательные рассылки не требуются (связь точка‑точка).
- Это экономит адреса: вместо `/30` (4 адреса, из них 2 полезных) используется `/31` (2 адреса, оба полезных).

**Проверка на примере**
- Сеть: `197.220.12.8/31` (адрес сети определяется по маске).
- Доступные хосты:
  - `197.220.12.9` (последний бит `1`),
  - `197.220.12.10` (последний бит `0`).
- Нет «потерянных» адресов на сеть/broadcast — оба адреса используются.

---

## 8. Содержимое ARP-таблицы изменяется в результате следующих событий</br> (выберите вариант ответа):</br> а) при получении ARP-ответов на запрос;</br> б) при получении широковещательных ARP-запросов;</br> в) по истечении времени жизни записи в ARP-таблице.

Ответ а), б), в)

**ARP‑таблица** — это «телефонная книжка» устройства в сети, где хранятся **пары «IP‑адрес → MAC‑адрес»** известных ему соседей.

### Зачем нужна
Чтобы устройство могло отправлять данные другому устройству в локальной сети, оно должно знать:
- **IP‑адрес получателя** (логический адрес, как номер телефона);
- **MAC‑адрес получателя** (физический адрес сетевой карты, как имя абонента).

ARP‑таблица связывает эти два адреса. Без неё каждое отправление пакета требовало бы нового запроса «кто имеет этот IP?».

### Что хранится в таблице
- **IP‑адрес** устройства‑соседа;
- **MAC‑адрес** этого устройства;
- **интерфейс**, через который оно доступно;
- **таймер жизни** записи (когда её нужно удалить).

### Как заполняется
**Автоматически** — через ARP‑запросы и ответы:
- Устройство спрашивает: «Кто имеет IP 192.168.1.100? Ответь!» (ARP‑запрос).
- Устройство с этим IP отвечает: «Это я, мой MAC — AA:BB:CC:DD:EE:FF» (ARP‑ответ).
- Отправитель добавляет пару `(192.168.1.100 → AA:BB:CC:DD:EE:FF)` в свою ARP‑таблицу.
- 
**При анализе чужих запросов** — если устройство видит ARP‑запрос от соседа, оно может запомнить его IP и MAC, даже если запрос не к нему.

**Вручную** — администратор может добавить статические записи (они не истекают).

### Как обновляется и очищается
- **Обновление:** при получении нового ARP‑ответа или при повторном обнаружении устройства таймер жизни записи сбрасывается.
- **Удаление:** по истечении таймера запись исчезает (чтобы не хранить устаревшие данные).

### Пример таблицы
```
IP‑адрес         | MAC‑адрес           | Интерфейс | Время до удаления
192.168.1.100  | AA:BB:CC:DD:EE:FF | eth0    | 120 сек
192.168.1.101  | 11:22:33:44:55:66 | eth0    | 90 сек
```

**а) При получении ARP‑ответов на запрос**
- Когда устройство отправляет **ARP‑запрос** («Кто имеет IP‑адрес X.X.X.X? Ответь!»), оно ждёт ответа.
- Получив **ARP‑ответ** («Я имею IP‑адрес X.X.X.X, мой MAC‑адрес — AA:BB:CC:DD:EE:FF»), устройство:
  - добавляет пару «IP‑адрес → MAC‑адрес» в свою ARP‑таблицу;
  - обновляет время жизни (TTL) этой записи.
- **Итог:** таблица пополняется или обновляется.

**б) При получении широковещательных ARP‑запросов**
- Если устройство получает **широковещательный ARP‑запрос** (например, «Кто имеет IP 192.168.1.100? Ответь!»), оно:
  - проверяет, относится ли запрос к его собственному IP‑адресу;
  - если да — отправляет ARP‑ответ;
  - **но даже если нет** — анализирует исходный IP‑ и MAC‑адрес отправителя запроса и **добавляет их в свою ARP‑таблицу** (предварительно).
- **Зачем:** чтобы не тратить время на новый ARP‑запрос, если вскоре понадобится связаться с этим устройством.
- **Итог:** таблица может пополниться записью о другом устройстве без явного запроса.

**в) По истечении времени жизни записи в ARP‑таблице**
- Каждая запись в ARP‑таблице имеет **таймер жизни** (TTL, обычно от нескольких минут до часов).
- Когда таймер истекает, запись:
  - автоматически удаляется из таблицы;
  - считается устаревшей.
- **Зачем:** чтобы таблица не разрасталась бесконечно и не хранила неактуальные данные (например, если устройство отключилось
или сменило MAC‑адрес).
- **Итог:** таблица очищается от устаревших записей.

---

## 9. Протокол ARP функционально можно разделить на клиентскую и серверную части. Опишите, какие функции вы отнесли бы к клиентской части, а какие — к серверной?

**Клиентская часть** (инициатор запроса):
- **Отправляет ARP‑запрос** («Кто имеет IP‑адрес X.X.X.X? Ответьте!») в локальную сеть (широковещательно).
- **Ожидает ARP‑ответ** от устройства с нужным IP.
- **Обновляет свою ARP‑таблицу** при получении ответа (добавляет пару «IP → MAC»).
- **Использует MAC‑адрес** из ответа для отправки кадров на целевое устройство.

*Когда срабатывает:* когда устройству нужно отправить данные в локальной сети, но в его ARP‑таблице нет MAC‑адреса получателя.


**Серверная часть** (ответчик):
- **Принимает ARP‑запросы**, адресованные её IP‑адресу.
- **Формирует и отправляет ARP‑ответ** («Это я! Мой MAC‑адрес — AA:BB:CC:DD:EE:FF»).
- **Может «предварительно заполнять» свою ARP‑таблицу**, анализируя IP‑ и MAC‑адреса отправителя запроса (даже если запрос не к ней).

*Когда срабатывает:* при получении ARP‑запроса, где указан IP‑адрес этого устройства.


### Простой пример
1. **Клиент** (устройство A, IP 192.168.1.10):
  - Нужно отправить пакет на 192.168.1.20, но MAC‑адрес неизвестен.
  - Отправляет широковещательный ARP‑запрос: «Кто 192.168.1.20? Ответьте!».
2. **Сервер** (устройство B, IP 192.168.1.20):
  - Получает запрос, видит, что он к её IP.
  - Отправляет ARP‑ответ: «Я 192.168.1.20, мой MAC — 00:11:22:33:44:55».
3. **Клиент** (устройство A):
  - Получает ответ, добавляет в ARP‑таблицу: `192.168.1.20 → 00:11:22:33:44:55`.
  - Теперь может отправлять кадры на устройство B.

---

## 10. В чём состоят функции нижнего уровня стека ТСР/IP</br> (выберите вариант ответа):</br> а) кодирование и мультиплексирование электрических сигналов;</br> б) инкапсуляция и декапсуляция данных сетевого уровня в кадры нижележащей технологии;</br> в) формирование кадров и синхронизация;</br> г) доступ к среде передачи;</br> д) преобразование сетевых адресов в адреса нижележащей технологии.

Ответ б), д)

**б) Инкапсуляция и декапсуляция данных сетевого уровня в кадры нижележащей технологии**
- Нижний уровень (канальный, *Link Layer*) берёт **пакет IP** (данные сетевого уровня) и «упаковывает» его в **кадр** 
той технологии, по которой идёт передача (Ethernet, Wi‑Fi, PPP и т.п.).
- При приёме — наоборот: снимает кадр, извлекает IP‑пакет и передаёт его вверх по стеку.
- Это и есть инкапсуляция (вложение) и декапсуляция (распаковка).

**д) Преобразование сетевых адресов в адреса нижележащей технологии**
- IP‑адреса (сетевой уровень) нужно сопоставить с **физическими MAC‑адресами** (канальный уровень).
- За это отвечает **ARP** (для IPv4): по IP находит MAC и формирует кадр с корректными MAC‑адресами получателя и отправителя.
- Для IPv6 аналогичную роль играет NDP.

#### Почему не а), в), г)
**а) Кодирование и мультиплексирование электрических сигналов**
- Это задачи **физического уровня** (например, модуляция, битовое кодирование, синхронизация сигналов).
- В модели TCP/IP «нижний уровень» обычно понимают как **канальный** (а не физический), поэтому этот пункт не относится.

**в) Формирование кадров и синхронизация**
- «Формирование кадров» частично входит в инкапсуляцию, но «синхронизация» — это опять‑таки физический уровень 
(битовая синхронизация, тактование).
- В контексте TCP/IP нижний уровень не занимается низкоуровневой синхронизацией сигналов — это вне его зоны ответственности.

**г) Доступ к среде передачи**
- Механизмы доступа к среде (CSMA/CD, CSMA/CA, TDMA и т. п.) действительно работают на канальном уровне.
- Однако в формулировке вопроса акцент на **функциях именно стека TCP/IP**, а не на общих функциях канального уровня.
- В TCP/IP доступ к среде обычно «делегирован» нижележащим технологиям (Ethernet, Wi‑Fi и т.п.), а не реализуется самим 
стеком TCP/IP. Поэтому этот пункт менее точен в данном контексте.

---

## 11. Поясните, что понимается под термином «линия связи» (Link) в технологии TCP/IP</br> (выберите вариант ответа):</br> а) любая коммуникационная среда, которая позволяет IP-узлам взаимодействовать друг с другом без промежуточных маршрутизаторов;</br> б) физическая линия связи (отрезок кабеля) с работающим на ней протоколом канального уровня;</br> в) локальная сеть, построенная на коммутаторах, связывающая интерфейсы маршрутизаторов;</br> г) отдельный логический канал MPLS.

Ответ а), б), в), г)

### а) Любая коммуникационная среда, которая позволяет IP‑узлам взаимодействовать друг с другом без промежуточных маршрутизаторов
- **Суть:** «линия связи» — это среда, где узлы «видят» друг друга напрямую на канальном уровне (L2).
- **Примеры:** Ethernet‑сегмент, Wi‑Fi‑сеть, точка‑точка‑канал (PPP).
- **Почему верно:** если два IP‑узла обмениваются данными без маршрутизации (т.е. в одной L2‑домене), это и есть «линия связи».
Маршрутизаторы здесь не участвуют — пакеты идут напрямую.

#### б) Физическая линия связи (отрезок кабеля) с работающим на ней протоколом канального уровня
- **Суть:** «линия» может быть и физической средой (кабель, оптика, радиоканал), но обязательно с канальным протоколом 
(Ethernet, PPP, HDLC и т.п.).
- **Почему верно:** TCP/IP абстрагируется от физики, но «линия связи» подразумевает наличие *физической среды + канального протокола* —
без этого передача кадров невозможна.

#### в) Локальная сеть, построенная на коммутаторах, связывающая интерфейсы маршрутизаторов
- **Суть:** коммутаторы создают единый L2‑домен, где IP‑интерфейсы маршрутизаторов могут обмениваться кадрами напрямую.
- **Пример:** два маршрутизатора подключены к одному Ethernet‑коммутатору; их IP‑интерфейсы находятся в одной подсети и 
общаются через L2‑кадры.
- **Почему верно:** такая сеть — типичный пример «линии связи» для TCP/IP: узлы в ней взаимодействуют без маршрутизации 
между ними.

#### г) Отдельный логический канал MPLS
- **Суть:** MPLS создаёт виртуальные каналы (LSP) поверх транспортной сети. Для IP‑уровня такой канал выглядит как «прямая»
линия связи между двумя точками.
- **Почему верно:** с точки зрения стека TCP/IP, MPLS‑туннель — это «линия связи»: IP‑пакеты инкапсулируются в MPLS‑метки
и передаются как по «прямой» L2‑линии, даже если физически путь сложный.

### Почему все варианты подходят
Термин «линия связи» (*Link*) в TCP/IP **охватывает разные уровни абстракции**:
- **Физическую среду** (кабель + канальный протокол, вариант б).
- **Логическую L2‑среду** (Ethernet‑сегмент, Wi‑Fi, вариант а и в).
- **Виртуальные каналы** (MPLS, VPN, вариант г).

**Главное условие:** на этой «линии» IP‑узлы могут обмениваться данными **без маршрутизации** (т.е. на канальном уровне).
Всё, что удовлетворяет этому, считается *Link* в контексте TCP/IP.

---

## 12. Передаётся ли в IP-пакете маска в тех случаях, когда маршрутизация реализуется с использованием масок?

Ответ нет

В заголовке IP‑пакета **маска подсети не передаётся**.

### Почему так
**Задача IP‑пакета** — доставить данные от отправителя к получателю по IP‑адресам. В его заголовке есть:
- IP‑адрес источника;
- IP‑адрес назначения;
- другие служебные поля (TTL, протокол, контрольная сумма и т.п.).

Но **нет поля для маски подсети**.

**Маски используются локально**
- Маска нужна на **конечных узлах** (ПК, серверах) и **маршрутизаторах**, чтобы:
  - определить, находится ли получатель в той же подсети или в другой;
  - вычислить адрес сети из IP‑адреса;
  - выбрать маршрут (через шлюз или напрямую).
- Эти расчёты делаются **на устройстве**, а не передаются в пакете.

**Как работает маршрутизация без маски в пакете**
- У каждого интерфейса маршрутизатора и узла настроена своя маска подсети.
- При получении пакета устройство:
  1. Сравнивает IP‑адрес получателя с собственной сетью (используя свою маску).
  2. Если получатель «свой» (в той же подсети) — отправляет кадр напрямую (через ARP).
  3. Если «чужой» — направляет пакет на шлюз по умолчанию (согласно таблице маршрутизации).
- Маска **не нужна в пакете**, потому что каждый узел уже знает свою маску из конфигурации.

### Пример
- Узел `192.168.1.10/24` хочет отправить пакет на `192.168.2.20`.
- Он «знает» свою маску `255.255.255.0` и понимает, что `192.168.2.20` — из другой сети.
- Пакет отправляется на шлюз (маршрутизатор), но в самом пакете **нет маски** — только IP‑адреса.
- Маршрутизатор использует свои таблицы и маски, чтобы решить, куда дальше направить пакет.

### Итог
Маска подсети — это **локальная настройка устройства**, а не часть IP‑пакета. Она нужна для принятия решений на узлах и
маршрутизаторах, но **не передаётся в составе пакета**.

---

## 13. Какие элементы сети могут выполнять фрагментацию?</br> Варианты ответов:</br> а) только компьютеры;</br> б) только маршрутизаторы;</br> в) компьютеры, маршрутизаторы, мосты, коммутаторы;</br> г) компьютеры и маршрутизаторы.

Ответ г)

**Фрагментация** — это разбиение большого IP‑пакета на более мелкие части, если его размер превышает **MTU** (Maximum Transmission Unit)
выходного интерфейса.

### Компьютеры (конечные узлы)
- Выполняют фрагментацию **при отправке данных**, если:
  - приложение или транспортный уровень (например, TCP) передаёт пакет, превышающий MTU сети;
  - в заголовке IP не установлен флаг *DF* («не фрагментировать»).
- Пример: ПК отправляет файл через Ethernet (MTU = 1500 байт), но пакет имеет размер 2000 байт → ПК разбивает его на фрагменты.

### Маршрутизаторы
- Выполняют фрагментацию **на пересылке**, если:
  - пакет пришёл через интерфейс с большим MTU, а выходит через интерфейс с меньшим MTU;
  - флаг *DF* не запрещён.
- Пример: пакет 1500 байт пришёл на маршрутизатор через Ethernet, а дальше идёт через PPP‑канал с MTU = 576 байт → маршрутизатор
разбивает пакет на фрагменты.

### Почему не другие варианты
**а) Только компьютеры** — неверно. Маршрутизаторы тоже фрагментируют пакеты при смене сетей с разным MTU.

**б) Только маршрутизаторы** — неверно. Конечные узлы (компьютеры) могут фрагментировать пакеты ещё на этапе отправки.

**в) Компьютеры, маршрутизаторы, мосты, коммутаторы** — неверно:
- **Мосты и коммутаторы** работают на **канальном уровне** (L2). Они пересылают кадры, но:
  - не анализируют IP‑заголовки;
  - не умеют фрагментировать IP‑пакеты;
  - просто передают кадры целиком или отбрасывают их, если размер превышает MTU порта.

### Итог
Фрагментацию выполняют:
- **компьютеры** — при отправке, если пакет слишком большой;
- **маршрутизаторы** — при пересылке между сетями с разным MTU.

Мосты и коммутаторы фрагментацией **не занимаются** — это задача сетевого уровня (L3), а не канального (L2).

---

## 14. Что произойдёт, если при передаче пакета он был фрагментирован, причём один из фрагментов не дошёл до узла назначения по истечении тайм-аута?</br> Варианты ответов:</br> а) IP-модуль узла-получателя отбросит все полученные фрагменты пакета, в котором потерялся один фрагмент, а IP-модуль узла-отправителя не будет предпринимать никаких действий по повторной передаче данного пакета;</br> б) IP-модуль получателя сообщит о неполучении одного фрагмента, а IP-модуль узла-отправителя повторит передачу недошедшего фрагмента;</br> в) IP-модуль получателя сообщит о неполучении одного фрагмента, а IP-модуль узла-отправителя повторит передачу всего пакета, в состав которого входил недошедший фрагмент.

Ответ а)

IP‑протокол (IPv4) **не гарантирует доставку** и **не реализует механизм повторной передачи** потерянных фрагментов. Вот 
как это работает:

**Фрагментация**
- Пакет разбивается на фрагменты при передаче через сети с разным MTU.
- Каждый фрагмент — самостоятельный IP‑пакет с полями:
  - *Identification* (идентификатор пакета);
  - *Fragment Offset* (смещение фрагмента);
  - *Flags* (флаги, включая *More Fragments*);
  - *Total Length* (длина фрагмента).


**Что происходит при потере фрагмента**
- Если хотя бы один фрагмент не дошёл до получателя, **восстановить исходный пакет невозможно**.
- Получатель ждёт все фрагменты в течение **тайм‑аута** (обычно несколько секунд).
- По истечении тайм‑аута:
  - **все полученные фрагменты отбрасываются** (они бесполезны без недостающего);
  - никакой сигнал об ошибке не отправляется отправителю.

**Почему отправитель не повторяет передачу**
- IP‑уровень **не имеет механизма подтверждения** (ACK) и повторной отправки фрагментов.
- Ответственность за надёжность лежит на **верхних уровнях** (например, TCP):
  - TCP обнаружит потерю данных (по отсутствию ACK или дубликатам ACK);
  - повторно передаст **весь исходный пакет** (а не отдельный фрагмент);
  - при повторной передаче IP‑слой может снова фрагментировать его, если нужно.

### Почему не другие варианты
**б)** Неверно.
- IP‑получатель **не сообщает** отправителю о потере фрагмента (нет механизма обратной связи на уровне IP).
- Отправитель **не может** повторить передачу только одного фрагмента — IP не хранит историю фрагментов.

**в)** Неверно.
- IP‑получатель **не уведомляет** отправителя о проблеме.
- Повторную передачу всего пакета инициирует **только верхний уровень** (TCP), а не IP‑модуль отправителя.

---

## 15. Кому адресовано ICMP-сообщение?</br> Варианты ответов:</br> а) протоколу IP узла-отправителя пакета, вызвавшего ошибку;</br> б) протоколу транспортного или прикладного уровня узла-отправителя пакета, вызвавшего ошибку;</br> в) протоколу IP ближайшего маршрутизатора, от которого поступил пакет, вызвавший ошибку.

Ответ б)

**ICMP‑сообщение** (Internet Control Message Protocol — протокол межсетевых управляющих сообщений) — это служебное сообщение
в сетях TCP/IP, которое **передаёт информацию об ошибках и исключительных ситуациях** при доставке IP‑пакетов.

### Ключевые особенности
- **Не передаёт пользовательские данные** — служит только для диагностики и управления сетью.
- **Инкапсулируется в IP‑пакет** — ICMP‑сообщение отправляется внутри обычного IP‑пакета.
- **Работает на сетевом уровне** (уровень 3 модели OSI), тесно связан с IP.
- **Не гарантирует доставку** — как и IP, ICMP не имеет механизмов подтверждения и повторной передачи.

### Для чего используется
- Сообщать отправителю о **невозможности доставить пакет** (например, «сеть недоступна»).
- Информировать о **превышении времени жизни пакета** (TTL = 0).
- Помогать в **диагностике сети** (утилиты `ping` и `traceroute`).
- Передавать **служебные команды** (например, перенаправление маршрута).

### Примеры ICMP‑сообщений
- **Echo Request / Echo Reply** (`ping`) — проверка доступности узла.
- **Destination Unreachable** — пункт назначения недоступен.
- **Time Exceeded** — время жизни пакета истекло.
- **Redirect** — предложение изменить маршрут.

### Как доставляется
- ICMP‑сообщение **адресуется IP‑адресу отправителя** исходного пакета, вызвавшего ошибку.
- На целевом узле оно поднимается **до транспортного или прикладного уровня** (TCP, UDP, приложения), чтобы те могли 
отреагировать на ошибку.

### Важно
- ICMP **не используется** для обычной передачи данных между приложениями.
- Часто **фильтруется или ограничивается** в сетях из‑за рисков безопасности (например, атаки типа *Ping Flood*).

**Коротко:** ICMP‑сообщение — это «сигнал тревоги» в IP‑сети: оно сообщает об ошибках, помогает диагностировать проблемы
и управлять трафиком, но не переносит пользовательские данные.

ICMP‑сообщение **адресуется отправителю исходного пакета** (узлу, который послал пакет, вызвавший ошибку), но 
**доставляется не напрямую IP‑протоколу**, а поднимается на верхние уровни — к транспортному или прикладному протоколу,
инициировавшему передачу.

**Кто отправляет ICMP‑сообщение**
- Устройство (узел или маршрутизатор), обнаружившее ошибку при обработке пакета (например, «сеть недоступна», «время жизни
пакета истекло», «параметр некорректен»).

**Куда направляется ICMP‑сообщение**
- В заголовке ICMP указывается **IP‑адрес исходного отправителя** — того, кто послал проблемный пакет.
- ICMP‑пакет маршрутизируется обратно к этому узлу.

**Кому именно в узле‑отправителе оно «предназначено»**
- На целевом узле ICMP‑сообщение:
  - принимается IP‑модулем;
  - **не передаётся напрямую IP‑уровню как обычный пакет**, а интерпретируется как *сообщение об ошибке*;
  - передаётся вверх по стеку — к транспортному уровню (TCP, UDP) или к прикладному процессу (например, утилитам `ping`, `traceroute`),
  которые могут обработать ошибку.

→ То есть ICMP‑сообщение «адресовано» **не IP‑протоколу как таковому**, а **вышележащим протоколам/приложениям**, которые
инициировали отправку исходного пакета.

### Почему не другие варианты
**а)** Неверно.
- ICMP‑сообщение *приходит* на IP‑уровень узла‑отправителя, но **не «адресовано» ему как конечному получателю**.
- IP‑уровень лишь доставляет ICMP наверх — к транспортным/прикладным протоколам.
- Если бы ICMP адресовался только IP, верхние уровни не узнали бы об ошибке.

**в)** Неверно.
- ICMP‑сообщение направляется **не ближайшему маршрутизатору**, а **исходному отправителю пакета**, вызвавшего ошибку.
- Маршрутизатор, обнаруживший ошибку, формирует ICMP‑ответ *от своего имени*, но адресует его **именно отправителю**, 
а не себе или соседнему маршрутизатору.

---

## 16. Сколько ARP-таблиц имеет компьютер? маршрутизатор? коммутатор?

Поскольку ARP-таблица строится для каждого интерфейса, то число таблиц для каждого из этих устройств равно количеству их
сетевых интерфейсов с назначенными IP-адресами.

---

## 17. В студенческом общежитии живёт 350 студентов, и каждый из них имеет собственный ноутбук. В общежитии оборудована специальная комната, в которой развёрнута компьютерная сеть, имеющая 20 коннекторов для подключения компьютеров. Время от времени студенты работают в этом компьютерном классе, подключая свои ноутбуки к сети. Каким количеством IP-адресов должен располагать администратор этой компьютерной сети, чтобы все студенты могли подключаться к сети, не выполняя процедуру конфигурирования своих ноутбуков при каждом посещении компьютерного класса?

Ответ - 20 адресов (при условии, что в сети установлен DHCP-сервер)

**DHCP‑сервер** — это сервер (или сервис), который автоматически раздаёт IP‑адреса и другие сетевые настройки (маска подсети,
шлюз, DNS‑серверы) устройствам при их подключении к сети.

### Как работает
1. Устройство (клиент) подключается к сети и отправляет запрос «дайте IP».
2. DHCP‑сервер выбирает свободный IP из своего пула и отправляет клиенту вместе с прочими настройками.
3. Клиент использует полученный IP в течение заданного времени (срок аренды), потом может обновить аренду или получить 
новый адрес.

### Зачем нужен
- **Автоматизация**: не надо вручную назначать IP каждому устройству.
- **Избегание конфликтов**: сервер следит, чтобы один IP не достался двум устройствам.
- **Гибкость**: мобильные устройства получают IP при подключении к разным сегментам сети.
- **Упрощение администрирования**: централизованное управление настройками сети.

### Что выдаёт DHCP‑сервер
- IP‑адрес;
- маску подсети;
- адрес основного шлюза;
- адреса DNS‑серверов;
- время аренды IP‑адреса;
- другие параметры (прокси, домен и т.п.).

**Суть задачи**
- В компьютерном классе **20 физических коннекторов** (портов/розеток) — значит, одновременно к сети может подключиться
**не более 20 устройств**.
- Студенты приходят по очереди, подключают свои ноутбуки, но не хотят вручную настраивать IP при каждом визите.

**Почему хватает 20 адресов**
- Если в сети работает **DHCP‑сервер**, он автоматически раздаёт IP‑адреса устройствам при подключении.
- DHCP выделяет адрес **только на время сеанса** (на срок аренды, например, 8 часов).
- Когда студент отключает ноутбук, адрес **возвращается в пул** и может быть выдан другому устройству.
- Поскольку одновременно подключено максимум 20 ноутбуков, достаточно иметь **пул из 20 IP‑адресов** — они будут переиспользоваться
разными студентами.

**Почему не 350 адресов**
- Все 350 студентов **никогда не подключаются одновременно** (в классе всего 20 портов).
- Фиксировать 350 статических IP бессмысленно:
  - большинство адресов будут простаивать;
  - придётся вручную настраивать каждый ноутбук;
  - сложно управлять изменениями.

**Роль DHCP**
- **Автоматизация**: ноутбуки получают IP «сами» при подключении (не нужно вводить настройки вручную).
- **Переиспользование**: один и тот же IP может достаться разным ноутбукам в разное время.
- **Гибкость**: если кто‑то отключился, его адрес быстро выдаётся новому устройству.

---

## 18. Какие из следующих утверждений верны (выберите вариант ответа):</br> а) broadcast является частным случаем multicast;</br> б) broadcast является частным случаем anycast;</br> в) multicast является частным случаем anycast;</br> г) ни один из этих способов рассылки не является частным случаем другого.

Ответ а)

### Кратко о типах рассылки
- **Unicast** — один отправитель → один получатель.
- **Multicast** — один отправитель → *заданная группа* получателей (специальные IP‑адреса 224.0.0.0–239.255.255.255).
- **Broadcast** — один отправитель → *все* узлы в сети (специальные широковещательные адреса, например 255.255.255.255).
- **Anycast** — один отправитель → *ближайший* узел из группы потенциальных получателей (в IPv6 распространён; 
в IPv4 используется ограниченно).

**Multicast** подразумевает доставку пакета *группе* получателей.
**Broadcast** можно рассматривать как *крайний случай multicast*, где группа — это *все узлы* в сегменте сети.
Оба типа используют специальные IP‑адреса и механизмы групповой доставки; broadcast просто задаёт «группу» максимально широкой.

### Почему остальные варианты неверны
- **б) broadcast является частным случаем anycast** — нет.
  - Anycast выбирает *один* ближайший узел из группы; broadcast доставляет пакет *всем* узлам. Это принципиально разные модели.
- **в) multicast является частным случаем anycast** — нет.
  - Multicast рассылает пакет *многим* получателям одновременно; anycast — *одному* (ближайшему). Логика и цели разные.
- **г) ни один из этих способов…** — не подходит, потому что а) верно.

---

## 19. Почему провайдеры при выделении адресов своим клиентам стремятся к тому, чтобы адресные пространства сетей, располагающихся территориально по соседству, имели совпадающие префиксы?

Ответ - для агрегирования(суммирования) трафика(маршрутов) — это упрощает и ускоряет маршрутизацию.

**Что такое префикс**
- Префикс (например, `192.0.2.0/24`) задаёт диапазон IP‑адресов сети. Маршрутизаторы используют префиксы, чтобы понимать,
куда направлять пакеты.

**Проблема без агрегирования**
- Если у каждой маленькой сети свой уникальный префикс, маршрутизаторы хранят **множество отдельных записей** (например,
1000 сетей → 1000 строк в таблице маршрутизации).
- Это:
  - увеличивает размер таблиц маршрутизации;
  - замедляет поиск нужного маршрута;
  - повышает нагрузку на процессоры маршрутизаторов;
  - усложняет управление сетью.

**Как помогает агрегирование**
- Если соседние сети имеют **близкие/совпадающие префиксы** (например, `192.0.2.0/24`, `192.0.2.16/28`, `192.0.2.32/27`),
их можно «свернуть» в **один общий префикс** (например, `192.0.2.0/22`).
- Результат:
  - в таблицах маршрутизации хранится **одна запись** вместо множества;
  - маршрутизаторы быстрее находят маршрут (меньше проверок);
  - сеть работает стабильнее и масштабируемее.

**Выгоды для провайдера**
- **Экономия ресурсов**: меньше памяти и CPU на маршрутизаторах.
- **Устойчивость**: меньше обновлений при изменениях в сети.
- **Масштабируемость**: легко добавлять новые сети в рамках существующего агрегированного блока.
- **Упрощение политик**: легче настраивать фильтрацию и QoS для целого региона/блока адресов.

### Пример
- Без агрегирования:
  - 10 сетей → 10 записей в таблице маршрутизации.
- С агрегированием:
  - те же 10 сетей описываются **одной записью** `192.0.2.0/22`.
  - маршрутизатор направляет весь трафик для этого блока по одному пути.

---

## 20. Какие из следующих утверждений правильны (выберите вариант ответа):</br> а) клиентом DNS-сервера является резольвер;</br> б) DNS-клиентом является практически каждый узел Интернета;</br> в) запись типа АААА файла зоны отображает DNS-имя в IPv4-адрес;</br> г) для каждой зоны существует один первичный и несколько вторичных DNS-серверов.

Ответ а), б), г)

**а) Клиентом DNS‑сервера является резольвер** — **верно**.
- *Резольвер* — это программный компонент (на ПК, смартфоне, сервере), который отправляет DNS‑запросы к DNS‑серверам, чтобы
преобразовать доменное имя (например, `example.com`) в IP‑адрес.
- Именно он инициирует обращение к DNS‑серверу, поэтому считается его клиентом.

**б) DNS‑клиентом является практически каждый узел Интернета** — **верно**.
- Любое устройство, выходящее в Интернет (ПК, телефон, IoT‑устройство), регулярно обращается к DNS, чтобы:
  - открыть веб‑сайт;
  - отправить email;
  - подключиться к онлайн‑сервису.
- Значит, почти каждый узел выполняет роль DNS‑клиента.

**в) Запись типа АААА файла зоны отображает DNS‑имя в IPv4‑адрес** — **неверно**.
- Запись **AAAA** связывает доменное имя с **IPv6‑адресом** (например, `2001:db8::1`).
- Для **IPv4** используется запись **A** (например, `192.0.2.1`).
- Путать A и AAAA нельзя — это разные типы записей.

**г) Для каждой зоны существует один первичный и несколько вторичных DNS‑серверов** — **верно**.
- В DNS‑зоне обычно:
  - **один первичный (primary, master) сервер** — хранит оригинальную копию файла зоны и разрешает вносить изменения;
  - **несколько вторичных (secondary, slave) серверов** — копируют данные с первичного, отвечают на запросы и обеспечивают отказоустойчивость.
- Такая схема повышает надёжность и распределяет нагрузку.

---

## 21. Сравните таблицу моста или коммутатора с таблицей маршрутизатора. Каким образом формируются эти таблицы? Какую информацию содержат? От чего зависит их объём?

### 1. Как формируются таблицы
- **Таблица моста/коммутатора** (MAC‑таблица):
  - формируется **автоматически** на основе анализа проходящих кадров;
  - при получении кадра коммутатор «запоминает»:
    - MAC‑адрес отправителя;
    - порт, через который кадр пришёл;
  - записи обновляются динамически (с таймаутом старения).

- **Таблица маршрутизатора** (таблица маршрутизации):
  - может создаваться **двумя способами**:
    - **статически** — вручную администратором;
    - **динамически** — через протоколы маршрутизации (RIP, OSPF, BGP и др.), когда маршрутизаторы обмениваются информацией о сетях;
  - содержит маршруты к сетям, а не к отдельным устройствам.

### 2. Какую информацию содержат
- **Таблица моста/коммутатора**:
  - MAC‑адреса устройств;
  - номера портов коммутатора, к которым подключены устройства;
  - таймер старения записи (чтобы удалять устаревшие данные).

- **Таблица маршрутизатора**:
  - адреса сетей назначения (сетевой префикс + маска);
  - следующий переход (next hop) — IP‑адрес следующего маршрутизатора;
  - выходной интерфейс (через какой порт отправлять пакет);
  - метрика (число, оценивающее «стоимость» маршрута);
  - протокол, от которого получена запись (например, OSPF, статический).

### 3. От чего зависит объём
- **Таблица моста/коммутатора**:
  - от **числа активных устройств** в сегменте сети;
  - от **частоты смены устройств** (новые MAC‑адреса добавляются, старые удаляются по таймауту).

- **Таблица маршрутизатора**:
  - от **размера сети** (сколько сетей нужно знать);
  - от **топологии** (число альтернативных путей);
  - от **используемых протоколов маршрутизации** (некоторые генерируют больше записей);
  - от наличия **агрегированных маршрутов** (они сокращают число записей).

### Кратко: ключевые отличия
- **Уровень модели OSI**:
  - коммутатор — канальный (L2), работает с MAC‑адресами;
  - маршрутизатор — сетевой (L3), работает с IP‑адресами и сетями.
- **Принцип заполнения**:
  - коммутатор «учится» на проходящих кадрах;
  - маршрутизатор получает данные либо вручную, либо через протоколы.
- **Назначение**:
  - коммутатор направляет кадры **внутри одной сети**;
  - маршрутизатор направляет пакеты **между разными сетями**.

---

## 22. Рассмотрим маршрутизатор на магистрали Интернета. Какие записи содержатся в поле адреса назначения его таблицы маршрутизации?</br> Варианты ответов:</br> а) номера всех сетей Интернета;</br> б) номера некоторых сетей Интернета.</br> в) номера некоторых сетей и адреса некоторых конечных узлов Интернета;</br> г) номера сетей, подсоединённых к интерфейсам данного маршрутизатора.

Ответ в)

Маршрутизатор на магистрали Интернета **не хранит информацию обо всех сетях мира** (это невозможно из‑за масштаба), но и
**не ограничивается только «своими» сетями**. Его таблица маршрутизации содержит:
- **Номера некоторых сетей** (префиксы с масками, например, `192.0.2.0/24`) — это основные записи, описывающие достижимые сети.
- **Адреса некоторых конечных узлов** (в виде /32‑записей для IPv4 или /128 для IPv6) — такие записи появляются, например:
  - при статических маршрутах к конкретным серверам;
  - в результате работы протоколов маршрутизации (некоторые узлы анонсируются как «хост‑маршруты»);
  - для специальных сервисов или защищённых узлов, требующих индивидуального маршрута.

Таким образом, таблица сочетает:
- агрегированные записи о сетях (большинство);
- точечные записи о конкретных узлах (меньшинство, но они есть).

### Почему неверны другие варианты
**а)** *«номера всех сетей Интернета»* — **неверно**.
- Объём Интернета слишком велик: сотни тысяч сетей.
- Маршрутизаторы используют **агрегирование** (суммирование маршрутов), чтобы сократить число записей.
- Никто не хранит «все сети» — это сделало бы таблицы маршрутизации непомерно большими и медленными.

**б)** *«номера некоторых сетей Интернета»* — **частично верно, но неполно**.
- Да, в таблице есть префиксы сетей.
- Но **пропущены записи о конечных узлах** (/32 или /128), которые тоже встречаются.
- Ответ **в)** точнее, потому что учитывает оба типа записей.

**г)** *«номера сетей, подсоединённых к интерфейсам данного маршрутизатора»* — **неверно**.
- Это описание подходит для **крайнего** (edge) маршрутизатора в небольшой сети.
- На магистрали Интернет‑маршрутизатор знает **далеко не только «свои» сети**, а множество удалённых сетей, полученных через
BGP, OSPF и др.
- Его таблица строится на основе **обмена маршрутной информацией** с соседями, а не только на локальных подключениях.

---

## 23. Сколько записей о маршрутах по умолчанию может включать таблица маршрутизации?

Ответ - их может быть несколько. Выбор осуществляется на основе метрики или приоритета, а также для балансировки нагрузки.

**Что такое маршрут по умолчанию**
- Это «запасной» маршрут с префиксом `0.0.0.0/0` (IPv4) или `::/0` (IPv6).
- Используется, когда в таблице нет явного маршрута к целевому адресу.
- Аналог фразы «если не знаешь куда — пошли туда».

**Почему их может быть несколько**
- **Резервирование**: несколько шлюзов по умолчанию обеспечивают отказоустойчивость (если один упал — работает другой).
- **Балансировка нагрузки**: трафик можно распределять между несколькими шлюзами (например, через разные провайдеры или каналы).
- **Разные приоритеты/метрики**: администратор задаёт «вес» каждого маршрута — выбирается тот, у которого метрика лучше (меньше).


**Как выбирается нужный маршрут**
- **По метрике** (cost, distance): предпочтительнее маршрут с меньшим значением метрики.
- **По приоритету** (административному расстоянию): если метрики равны, выбирается маршрут с более высоким приоритетом.
- **По правилам балансировки**: например, round‑robin (по очереди) или на основе нагрузки канала.

**Пример**
- В таблице есть два маршрута по умолчанию:
  - `0.0.0.0/0 via 192.0.2.1, метрика=10`
  - `0.0.0.0/0 via 203.0.113.1, метрика=20`
- Будет выбран первый (`192.0.2.1`), так как его метрика меньше.

- **Ограничения**
- Технически число записей не фиксировано, но на практике их редко бывает больше 2–4 (иначе усложняется управление и возрастает риск ошибок).
- Некоторые устройства могут накладывать свои лимиты (зависит от ОС и оборудования).

---

## 24. Пусть префикс непрерывного пула IP-адресов составляет 12 двоичных разрядов.</br> Сколько адресов входит в этот пул?</br> Варианты ответов:</br> а) 2¹²;</br> б) 2²⁰;</br> в) 2¹² – 2;</br> г) 12².

Ответ б)

### Объяснение

**Что значит «префикс 12 двоичных разрядов»**
- Префикс `/12` означает, что **первые 12 бит** IP‑адреса фиксированы (определяют сеть), а **остальные биты** могут 
варьироваться (определяют хосты в этой сети).
- В IPv4 адрес имеет длину **32 бита**. Значит, на хосты остаётся:

  32 - 12 = 20 бит.

**Как посчитать число адресов**
- Каждый из 20 свободных бит может быть `0` или `1`.
- Общее число комбинаций (т.е. возможных адресов):  

  2^20.

- Это включает **все** адреса диапазона:
  - адрес сети (все биты хоста = `0`);
  - широковещательный адрес (все биты хоста = `1`);
  - все промежуточные адреса узлов.

**Почему не другие варианты**
  - **а)2¹²** — неверно. Это число комбинаций для 12 бит, но у нас на хосты отведено **20 бит**, а не 12.
  - **в)2¹²–2** — неверно. Вычитание `2` (адрес сети и широковещательный) применяется, когда считают **пригодные для узлов
адреса**, но вопрос спрашивает про **весь пул адресов**, а не только «полезные».
  - **г)12²** — неверно. Это арифметическая операция, не связанная с бинарным подсчётом адресов.

---

## 25. Передаётся ли в IP-пакете маска в тех случаях, когда маршрутизация реализуется с использованием масок?

Ответ - нет. Для правильной маршрутизации пакетов в сети с использованием масок достаточно того, что маски передаются протоколами 
маршрутизации RIP-2, OSPF или устанавливаются вручную для каждой записи таблицы маршрутизации.

**Что содержится в IP‑пакете**  
В заголовке IP‑пакета есть:
- IP‑адрес источника;
- IP‑адрес назначения;
- другие служебные поля (длина, TTL, протокол, контрольная сумма и т. п.).

**Маски подсети в заголовке нет.**

**Зачем тогда нужны маски**  
Маска подсети используется **локально** на узлах и маршрутизаторах:
- чтобы определить, находится ли получатель в той же подсети или в другой;
- для вычисления адреса сети из IP‑адреса;
- для выбора маршрута (через шлюз или напрямую).

**Откуда маршрутизаторы знают маски**  
Маски **не передаются в каждом IP‑пакете**, но попадают на маршрутизаторы другими путями:
- **Протоколы маршрутизации** (RIP‑2, OSPF, BGP и др.) распространяют информацию о сетях **вместе с масками подсетей**. 
Например, OSPF передаёт записи вида «сеть 192.168.1.0/24 доступна через следующий переход 10.0.0.1».
- **Ручная настройка**: администратор может прописать статические маршруты с масками (например, «маршрут к 192.168.2.0/24
через 10.0.0.2»).

**Как это работает на практике**
- Узел или маршрутизатор получает пакет.
- Смотрит на IP‑адрес назначения и сравнивает его с записями в таблице маршрутизации (где уже есть маски).
- Находит подходящий маршрут (самый длинный префикс, который совпадает) и отправляет пакет дальше.
- При этом **в самом пакете маски нет** — они уже «известны» маршрутизатору из его таблицы.

**Почему так спроектировано**
- **Экономия места**: добавление маски в каждый пакет увеличило бы его размер.
- **Эффективность**: маршрутизаторам достаточно иметь актуальную таблицу маршрутизации — они не должны «спрашивать» маску
у каждого пакета.
- **Разделение уровней**: IP‑пакет несёт данные, а информация о топологии сети (маски, маршруты) распространяется отдельно
(протоколами маршрутизации).

---

## 26. Приведите примеры, когда может возникнуть необходимость в использовании специфических маршрутов.

Специфические (детализированные) маршруты нужны, когда требуется **отклониться от «общего» пути**, заданного маршрутом по
умолчанию или агрегированными записями, и направить трафик особым образом.

### Примеры ситуаций

**ОбХОД отказавшего канала**
- Основной маршрут к сети `192.168.2.0/24` стал недоступен.
- Администратор вручную добавляет специфический маршрут через резервный шлюз, чтобы трафик шёл по альтернативному пути.

**Балансировка нагрузки между провайдерами**
- Есть два ISP‑подключения.
- Для части сетей (например, `10.0.1.0/24`) задаётся специфический маршрут через ISP 1, для других (`10.0.2.0/24`) — 
через ISP 2, чтобы распределить нагрузку.

**Приоритет для критичного трафика**
- Трафик к серверу баз данных (`192.168.5.10/32`) направляется через канал с низкой задержкой, а остальной трафик — по умолчанию.
- Специфический /32‑маршрут гарантирует, что пакеты к этому узлу пойдут строго по заданному пути.

**Сегментация и безопасность**
- Нужно изолировать трафик определённой подсети (например, гости Wi‑Fi `172.16.10.0/24`).
- Задаётся специфический маршрут, который направляет этот трафик через отдельный брандмауэр или VPN‑туннель.

**Тестирование и отладка**
- Временный специфический маршрут направляет трафик к тестовому серверу (`192.168.99.100/32`) через отдельный интерфейс
для захвата пакетов и анализа.

**Многосайтовая сеть с особыми требованиями**
- В филиалах используются одинаковые частные подсети (`192.168.1.0/24`), но трафик должен идти через разные VPN‑туннели.
- Для каждого филиала прописывается специфический маршрут с точным префиксом и шлюзом, чтобы избежать конфликтов.

**Оптимизация для приложений с жёсткими SLA**
- Для VoIP‑трафика к диапазону `10.10.5.0/28` задаётся маршрут через QoS‑канал с гарантированной полосой и низким джиттером.
- Остальной трафик идёт по общему маршруту.

**ОбХОД фильтров или политик провайдера**
- Провайдер блокирует или замедляет трафик к определённой сети.
- Добавляется специфический маршрут через другой шлюз/VPN, чтобы обойти ограничение.

### Почему это «специфические» маршруты
- Они **точнее** агрегированных записей (например, `/24` вместо `/16`).
- Имеют **более длинную маску подсети**, поэтому маршрутизатор выбирает их в приоритете над общими маршрутами.
- Позволяют **тонко управлять потоком трафика** там, где стандартных правил недостаточно.

---

## 27. Какие преимущества даёт технология CIDR? Что мешает её широкому внедрению?

### Преимущества CIDR (Classless Inter‑Domain Routing)
**Экономия IP‑адресов**
- Отказались от жёсткого деления на классы (A/B/C): теперь можно выделять сети точно под нужды (например, `/26` вместо целого класса C).
- Снижает расточительное распределение адресов.

**Агрегирование маршрутов (маршрутная суммизация)**
- Несколько сетей объединяются в один префикс (например, `192.0.2.0/24` + `192.0.2.16/28` → `192.0.2.0/22`).
- Уменьшает размер таблиц маршрутизации, ускоряет поиск маршрута, снижает нагрузку на маршрутизаторы.

**Гибкость адресации**
- Можно создавать подсети любого размера (от `/32` до `/0`), адаптируя маску под число узлов.
- Удобно для иерархического планирования адресов в крупных сетях.

**Улучшение масштабируемости Интернета**
- Меньше записей в глобальных таблицах маршрутизации → сеть работает стабильнее и быстрее.

### Что мешает широкому внедрению
**Legacy‑системы и устаревшее оборудование**
- Старые маршрутизаторы и ПО могут не поддерживать CIDR или работать с ним некорректно.
- Замена оборудования требует времени и денег.

**Сложность администрирования**
- Ручное управление множеством разноразмерных подсетей повышает риск ошибок (перекрытие адресов, неверные маски).
- Требуется квалифицированный персонал и тщательное документирование.

**Сопротивление изменениям**
- Организации с устоявшейся классовой адресацией неохотно переходят на CIDR из‑за затрат на переконфигурацию.
- Иногда проще оставить «как есть», даже если это менее эффективно.

**Проблемы совместимости с некоторыми приложениями**
- Некоторые старые приложения и скрипты рассчитывают на классовую адресацию (например, автоматически определяют маску по первому байту IP).
- Могут возникать сбои при переходе на произвольные префиксы.

**Ограничения провайдеров**
- Мелкие ISP иногда выдают клиентам только «стандартные» подсети (например, `/24`), не предлагая гибких вариантов.
- Это тормозит внедрение CIDR на уровне конечных пользователей.

**Переход на IPv6**
- Поскольку IPv6 решает проблему дефицита адресов, интерес к оптимизации IPv4 через CIDR снижается.
- Ресурсы вкладываются в миграцию на IPv6, а не в доработку IPv4‑маршрутизации.

### Итог
- **Плюсы CIDR**: экономия адресов, агрегирование, гибкость, масштабируемость.
- **Барьеры**: устаревшее оборудование, сложность управления, сопротивление изменениям, совместимость, переход на IPv6.

---

## 28. Почему в записи о маршруте по умолчанию в качестве адреса сети назначения часто указывается 0.0.0.0 с маской 0.0.0.0?

Запись `0.0.0.0/0` (адрес `0.0.0.0` с маской `0.0.0.0`) используется как маршрут по умолчанию, потому что **она совпадает
с любым IP‑адресом назначения**.

**Как работает маска `/0`**
- Маска `0.0.0.0` означает: **нет ни одного бита, отведённого под сеть** (все 32 бита «не учитываются»).
- При сравнении IP‑адреса назначения с записью `0.0.0.0/0` маршрутизатор видит: «любые биты подходят» — совпадение гарантировано.
- Это самый «нестрогий» префикс: он «покрывает» весь диапазон IPv4‑адресов (`0.0.0.0` – `255.255.255.255`).

**Почему это маршрут по умолчанию**
- Маршрутизатор ищет в таблице запись с **наиболее длинным совпадающим префиксом**.
- Если для конкретного адреса назначения нет явного маршрута (например, `192.0.2.0/24`), маршрутизатор проверяет запись `0.0.0.0/0`.
- Поскольку `0.0.0.0/0` совпадает с любым адресом, она выбирается как **«запасной» путь**, когда другие маршруты не подошли.

**Аналогия**
- Представьте справочник с разделами:
  - «Москва» → адрес 1
  - «Санкт‑Петербург» → адрес 2
  - «Любой город» → адрес 3
- Если ищете «Екатеринбург» и его нет в первых двух разделах, вы переходите к «Любой город».
- `0.0.0.0/0` — это и есть «Любой город» для IP‑маршрутизации.

**Где используется**
- На граничных маршрутизаторах (например, при подключении к ISP): если пакет не принадлежит ни одной известной сети, он 
отправляется на шлюз по умолчанию.
- В корпоративных сетях: чтобы направить «неизвестный» трафик на центральный маршрутизатор или VPN‑шлюз.

**Синтаксические варианты**
- `0.0.0.0 0.0.0.0` (в конфигурациях Cisco и др.)
- `default` (сокращённая запись в некоторых ОС и устройствах)
- `0/0` (в нотации CIDR)

---

## 29. В каких случаях система DNS использует протокол UDP, а в каких — TCP?

- **UDP (User Datagram Protocol («протокол пользовательских дейтаграмм»))** — основной протокол для DNS‑запросов и ответов.
- **TCP (Transmission Control Protocol («протокол управления передачей»))** — используется в особых случаях, когда UDP недостаточен.

### Когда используется UDP
**Стандартные DNS‑запросы клиентов** (поиск IP по имени и наоборот):
- Клиент (браузер, ОС) отправляет короткий запрос к DNS‑серверу.
- Сервер отвечает компактным ответом (обычно ≤ 512 байт).
- Пример: `dig example.com A` → UDP‑пакет.

**Почему UDP**
- **Быстрота**: нет установки соединения (handshake), меньше задержек.
- **Низкие накладные расходы**: короткий заголовок, нет управления потоком.
- **Достаточно для малых ответов**: большинство DNS‑ответов укладываются в 512 байт (ограничение стандарта для UDP).


### Когда используется TCP
**Ответы больше 512 байт**
- Если ответ не помещается в UDP‑пакет, сервер может ответить фрагментированным UDP (редко) или указать клиенту повторить запрос по TCP.
Примеры:
- большие DNSSEC‑ответы (с цифровыми подписями);
- ответы с множеством записей (MX, TXT, CNAME).

**Передача зон (zone transfer)**
- Когда вторичный DNS‑сервер запрашивает полную копию зоны у первичного (AXFR/IXFR).
- Данные могут быть объёмными — нужен надёжный поток (TCP).

**DNSSEC‑валидация**
- DNSSEC добавляет подписи (RRSIG, DNSKEY), заметно увеличивая размер ответов. TCP гарантирует доставку всех данных без потерь.

**Особые запросы**
- Некоторые расширенные операции (например, EDNS0 с большими буферами) могут требовать TCP, если UDP‑ограничения мешают.

**ОбХОД фильтров/блокировок**
- В сетях, где UDP‑трафик ограничен, DNS может использовать TCP как альтернативный канал.

### Почему не всегда TCP
- **Нагрузка на серверы**: TCP требует поддержания соединений (ресурсы памяти, CPU).
- **Задержки**: трёхэтапное установление соединения (SYN → SYN‑ACK → ACK) замедляет отклик.
- **Избыточность**: для 90% запросов UDP достаточно и эффективнее.

### Итог
- **UDP**:
  - стандартные запросы/ответы (поиск A, AAAA, CNAME и т.п.);
  - малые ответы (≤ 512 байт);
  - приоритет — скорость и простота.

- **TCP**:
  - ответы > 512 байт;
  - передача зон (AXFR/IXFR);
  - DNSSEC;
  - особые случаи, где нужна надёжность и полнота данных.

---

## 30. Если при обмене данными по методу с возвращением на N пакетов отправитель получил квитанцию на (n + 1)-й пакет, а квитанция на предыдущий n-й пакет не пришла, то</br> (выберите вариант ответа):</br> а) отправитель считает n-й пакет успешно принятым и продолжает передачу;</br> б) по истечении тайм-аута отправитель повторно отсылает n-й пакет;</br> в) по истечении тайм-аута получатель повторно отсылает квитанцию на n-й пакет.

Ответ а)

Метод с возвращением на *N* пакетов (Go‑Back‑*N*) работает так:
1. Отправитель передаёт **последовательность пакетов** подряд: *n*, *n* + 1, *n* + 2 и т.д.
2. Получатель отправляет **кумулятивную квитанцию** (ACK) — подтверждение приёма **всех пакетов до определённого номера включительно**.
3. Если пришла квитанция на *(n + 1)*‑й пакет, это значит:
  * получены и подтверждены **все пакеты до *n* + 1 включительно**;
  * в том числе подтверждён и *n*‑й пакет — даже если квитанция именно на него «потерялась» в сети.
4. Отправитель видит ACK(*n* + 1) и понимает: все пакеты до этого номера дошли. Он **не ждёт отдельной квитанции на *n*** 
и **продолжает передачу** следующих пакетов.

**Ключевая идея**: квитанция ACK(*k*) подтверждает приём **всех пакетов с номерами ≤ *k***.

### Почему неверны другие варианты
**б)** *«По истечении тайм‑аута отправитель повторно отсылает n‑й пакет»* — **неверно**.
* В Go‑Back‑*N* повторная отправка всего окна (начиная с потерянного пакета) происходит, только если **ни одна квитанция
после потерянного пакета не приходит долгое время** (истекло время ожидания).
* В условии сказано, что квитанция на *(n + 1)*‑й пакет **уже получена**. Это однозначно подтверждает, что *n*‑й тоже принят.
Тайм‑аут здесь не запускается.

**в)** *«По истечении тайм‑аута получатель повторно отсылает квитанцию на n‑й пакет»* — **неверно**.
* Получатель **не запускает тайм‑ауты** для повторной отправки квитанций. Его задача — отправить ACK на последний непрерывный
блок принятых пакетов.
* Если получатель уже отправил ACK(*n* + 1), он не будет повторно слать ACK(*n*) — это избыточно и противоречит логике протокола.

---

## 31. Как соотносятся размеры окна приёма и окна передачи в методе с выборочным повторением</br> (выберите вариант ответа):</br> а) окно передачи больше, чем окно приёма;</br> б) они равны;</br> в) окно приёма больше, чем окно передачи.

Ответ б)

В методе **выборочного повторения** (Selective Repeat ARQ) отправитель и получатель используют **окна одинакового размера**.
Это необходимо для корректной работы протокола.

### Почему окна должны быть равны
1. **Избегание двусмысленности при нумерации пакетов**
  - Пакеты нумеруются по модулю *N* (где *N* — размер окна).
  - Если окна не равны, может возникнуть ситуация, когда новый пакет с тем же номером «перекроет» старый, и получатель не
поймёт, повторный это пакет или новый.
  - Равенство окон гарантирует, что пока в системе есть пакеты с номерами из текущего окна, новые пакеты с такими же номерами не появятся.
2. **Синхронность буферизации**
  - Получатель буферизует пакеты, пришедшие не по порядку, до тех пор, пока не заполнится «пробел» от потерянного пакета.
  - Отправитель повторно передаёт только потерянные пакеты (не весь поток, как в Go‑Back‑N).
  - Чтобы буфер получателя не переполнялся и отправитель не «опережал» его возможности, размеры окон согласуются и остаются равными.
3. **Управление потоком**
  - Размер окна определяет, сколько пакетов можно передать без подтверждения.
  - Если окно отправителя будет больше окна получателя, получатель может не успеть обработать пакеты (переполнение буфера).
  - Если окно получателя будет больше окна отправителя, отправитель будет работать неэффективно (недоиспользует канал).

### Как это работает на практике
- Пусть размер окна = 4.
- Отправитель может передать до 4 пакетов подряд без подтверждений.
- Получатель готов принять до 4 пакетов (даже если они пришли не по порядку) и буферизовать их.
- Когда получатель подтверждает приём пакета, отправитель сдвигает окно и может отправить следующий пакет.
- Если пакет потерян, отправитель повторно передаёт **только его**, а не всю последовательность.


### Почему не другие варианты
- **а) окно передачи больше, чем окно приёма** — приведёт к перегрузке получателя: он не успеет обработать все пакеты, часть будет отброшена.
- **в) окно приёма больше, чем окно передачи** — отправитель не использует потенциал канала: мог бы отправить больше пакетов,
но ограничен своим окном.

---

## 32. Может ли приложение, используя протокол UDP, обеспечить надёжную связь?

Ответ - да, если оно для обеспечения надежности возьмет на себя функции, подобные функциям TCP, например квитирование, тайм-аут и т.п.

UDP сам по себе **не гарантирует** надёжности:
- не проверяет доставку пакетов;
- не упорядочивает пакеты;
- не повторяет отправку потерянных данных;
- не контролирует перегрузки.

Однако приложение **может добавить недостающие механизмы** и тем самым обеспечить надёжную связь.

### Какие функции нужно реализовать
Чтобы «надстроить» надёжность поверх UDP, приложение должно взять на себя задачи, аналогичные TCP:
1. **Квитирование (ACK)**
  - Отправитель нумерует пакеты.
  - Получатель отправляет подтверждение (ACK) для каждого принятого пакета.
  - Если ACK не пришёл — пакет считается потерянным и переотправляется.
2. **Тайм‑ауты (timeout)**
  - Отправитель ждёт ACK ограниченное время.
  - По истечении тайм‑аута пакет пересылается повторно.
3. **Нумерация и упорядочивание**
  - Пакеты нумеруются по порядку.
  - Получатель восстанавливает исходную последовательность, даже если пакеты пришли не по порядку.
4. **Контроль дубликатов**
  - Получатель отбрасывает повторные копии одного пакета (если ACK потерялся и отправитель переслал пакет ещё раз).
5. **Управление потоком и перегрузкой**
  - Ограничение скорости отправки, чтобы не перегрузить получателя или сеть.
  - Адаптация к условиям канала (например, уменьшение окна передачи при потерях).
6. **Контрольная сумма**
  - Проверка целостности данных (UDP уже имеет контрольную сумму, но приложение может усилить её или добавить свою).

### Когда это оправдано
Использовать UDP с «надстроенной» надёжностью разумно, если:
- нужна **низкая задержка** (например, в онлайн‑играх, VoIP, стриминге), а TCP слишком медленный из‑за трёхэтапного соединения
и строгого упорядочивания;
- требуется **частичная надёжность** (не все данные одинаково важны — можно потерять некоторые пакеты без критических последствий);
- необходимо **управлять качеством сервиса** на уровне приложения (например, приоритезировать одни пакеты над другими).

### Примеры реализаций
- **QUIC** (используется в HTTP/3): строит надёжность поверх UDP, включая шифрование, мультиплексирование и восстановление потерь.
- **RTP/RTCP** в VoIP и видеоконференциях: RTP передаёт медиа по UDP, а RTCP обеспечивает обратную связь и контроль качества.
- Игровые сетевые движки: часто реализуют свой протокол надёжности поверх UDP для минимизации задержек.

---

## 33. Какой объём данных получен в течение TCP-сеанса отправителем TCP-сегмента, в заголовке которого в поле квитанции помещено значение 160005, если известно, что первый полученный байт имел номер 15000?

Ответ 145005 байт.

В TCP каждый байт данных имеет порядковый номер. Поле **«квитанция» (ACK)** в заголовке сегмента означает:
> *«Я успешно получил все байты **до номера ACK − 1** включительно. Жду байт с номером ACK»*.

### Дано:
- Номер **первого полученного байта**: 15 000.
- Значение в поле **ACK**: 160 005.

### Что это значит:
- Получатель подтвердил приём всех байт **до 160 004** включительно (так как ACK = 160 005).
- Первый принятый байт имел номер 15 000.

### Вычисляем объём полученных данных:

Объём = Последний полученный байт - Первый полученный байт + 1

160 004 - 15 000 + 1 = 145 005 байт.


### Почему так
- TCP нумерует **каждый байт**, а не пакет.
- ACK не включает номер текущего сегмента, а указывает на **следующий ожидаемый байт**.
- Разница между ACK − 1 и номером первого байта даёт общий объём успешно принятых данных.

---

## 34. Укажите, в каком виде передаются квитанции на получение сегментов в протоколе TCP</br> (выберите вариант ответа):</br> а) квитанция передаётся в поле данных TCP-сегмента с установленным в заголовке флагом АСК;</br> б) квитанция — это флаг АСК;</br> в) квитанция — это значение поля последовательного номера в заголовке TCP-сегмента с установленным флагом АСК;</br> г) квитанция — это значение поля подтверждённого номера в заголовке TCP-сегмента с установленным флагом АСК.

Ответ г)

В TCP квитанция (подтверждение приёма) передаётся **не как отдельный пакет и не в поле данных**, а через комбинацию:
- **флага ACK** в заголовке сегмента (он *включает* механизм подтверждения);
- **поля «подтверждённый номер» (Acknowledgment Number, ACK number)** — именно в нём указано, *какой байт ожидается следующим*.

### Как это работает
1. **Флаг ACK**
  - Бит в заголовке TCP, сигнализирующий: «этот сегмент несёт подтверждение».
  - Без установленного флага ACK поле «подтверждённый номер» игнорируется.
2. **Поле «подтверждённый номер»**
  - Содержит число — *номер следующего ожидаемого байта*.
  - Например, если получатель отправил ACK = 1001, это значит: «я успешно принял все байты до 1000 включительно; жду байт 1001».
  - Это и есть *квитанция*: не список принятых пакетов, а «граница» успешно принятой последовательности.

### Почему не другие варианты
- **а)** Неверно. Квитанция **не передаётся в поле данных**. Она кодируется в заголовке (флаг ACK + поле ACK number).
- **б)** Неверно. Флаг ACK лишь *включает* механизм подтверждения, но сам по себе не является квитанцией. Квитанция — это *значение* в поле ACK number.
- **в)** Неверно. Поле «последовательный номер» (Sequence Number) указывает номер *отправляемых* байтов, а не подтверждённых.
Квитанция хранится в *другом* поле — «подтверждённый номер».

---

## 35. Проведите с партнёром сеанс моделирования работы протокола ТСР. Для этого договоритесь с ним о максимальном размере сегмента, о начальных размерах буферов, о начальном значении порядкового номера, о размерах окна. Затем асинхронно начинайте «посылать» друг другу «сегменты» — карточки, на которых заполнены ключевые поля: номер первого байта, размер посылаемого сегмента, номер квитанции и, если требуется, новое значение размера окна. Время от времени «теряйте» карточки при передаче и выполняйте действия, соответствующие логике ТСР. Не забудьте делать временные отметки на каждой копии отправленного сегмента, чтобы отслеживать приход квитанций. Выполнение этого задания не только сделает модуль ТСР более понятным для вас, но и, что гораздо важнее, породит новые вопросы.

**Участники:** «Отправитель» (А) и «Получатель» (Б).

**Шаг 1. Договориться о параметрах**

А и Б заранее согласовывают:
* максимальный размер сегмента — например, 100 байт;
* начальные размеры буферов: у А — 3 сегмента, у Б — 3 сегмента;
* начальный порядковый номер — например, 1 (с этого номера будут нумероваться байты);
* размер окна — например, 2 сегмента (А может отправить 2 сегмента, не дожидаясь подтверждения).

**Шаг 2. Подготовить «сегменты» (карточки)**

Каждая карточка (сегмент) содержит:
* **номер первого байта** (например, 1, 101, 201 — зависит от размера сегмента);
* **размер сегмента** (например, 100 байт);
* **номер квитанции** (уникальный номер для подтверждения, например, K1, K2, K3);
* **новое значение размера окна** (если меняется — например, «окно = 3»).

**Пример карточки:**
> № первого байта: 1
> Размер: 100 байт
> Номер квитанции: K1
> Размер окна: 2

**Шаг 3. Начать «передачу» (имитация асинхронного обмена)**

1. **А отправляет Б две карточки** (используя размер окна = 2).
2. **Б получает карточки**, проверяет целостность, заполняет квитанции (например, «Подтверждаю K1, K2») и возвращает их А.
3. **А получает квитанции**, обновляет порядковый номер и размер окна (если Б изменил).
4. **А отправляет следующие сегменты** (начиная с нового порядкового номера).

**Пример обмена:**
1. А → Б: сегмент 1 (байты 1–100, K1), сегмент 2 (байты 101–200, K2).
2. Б → А: «ACK: K1, K2 — получено».
3. А → Б: сегмент 3 (байты 201–300, K3), сегмент 4 (байты 301–400, K4).
4. Б → А: «ACK: K3, K4 — получено».

**Шаг 4. Имитировать потери сегментов**

Периодически «теряем» карточки (не передаём партнёру). Логика:
* если Б не получил сегмент — не отправляет ACK для него;
* А, не получив ACK в течение «таймаута» (например, 5 ходов), **повторяет отправку** потерянного сегмента;
* Б, получив дубликат, игнорирует его и отправляет ACK только для новых сегментов.

**Пример потери:**
1. А → Б: сегмент 5 (K5).
2. Карточка «теряется» (Б не получает).
3. А (через 5 ходов без ACK) → Б: сегмент 5 (K5) — повторная отправка.
4. Б → А: «ACK: K5 — получено».

**Шаг 5. Имитировать изменение размера окна**

Если Б сообщает «окно = 1», А может отправить только 1 сегмент без подтверждения. Если «окно = 3» — до 3 сегментов.

**Пример:**
1. Б → А: «Изменяю размер окна: 1».
2. А теперь отправляет только по 1 сегменту, дожидаясь ACK.

**Шаг 6. Отмечать время**

На каждой карточке пишем «время отправки» (например, ход 3, ход 7). На копиях — «время получения». Это имитирует таймауты и задержки.

**Шаг 7. Завершение**

Когда все данные переданы и подтверждены:
* А отправляет сегмент с флагом **FIN** (завершение передачи);
* Б отвечает **ACK** (подтверждает FIN);
* связь считается завершённой.

---

## 36. Как влияет на эффективность передачи протокола ТСР размер окна? Величина таймаута?

**Размер окна** в TCP — это объём данных (в байтах), который отправитель может передать, не дожидаясь подтверждения (ACK) 
от получателя.

**Влияние на эффективность:**
1. **Слишком маленький размер окна:**
  - отправитель ждёт подтверждения после каждой небольшой порции данных;
  - снижается скорость передачи;
  - увеличивается нагрузка на сеть из-за частых обменов подтверждениями.
2. **Слишком большой размер окна:**
  - риск перегрузки получателя (данные не успевают обрабатываться);
  - потери данных, задержки из-за переполнения буферов;
  - при потерях пакетов — повторная передача больших объёмов данных, что снижает эффективность
3. **Оптимальный размер:**
  - динамически настраивается в процессе передачи (механизм **Window Scaling**);
  - учитывает пропускную способность сети, задержки, состояние буферов;
  - обеспечивает баланс между скоростью и надёжностью.

**Особенности:**
- размер окна определяется как минимум из двух значений: окно приёма получателя и окно перегрузки (CWND) отправителя;
- при перегрузке сети размер окна уменьшается (например, вдвое при каждой проблеме);
- в надёжной сети с низкой задержкой можно использовать больший размер окна для максимальной утилизации канала.

### Как величина таймаута влияет на эффективность передачи по протоколу TCP?

**Таймаут** — это время ожидания отправителем подтверждения (ACK) перед повторной отправкой сегмента.

**Влияние на эффективность:**
1. **Слишком короткий таймаут:**
  - частые повторные передачи даже при нормальной задержке сети;
  - рост сетевого трафика, снижение полезной пропускной способности;
  - нестабильность соединения из-за «ложных» повторных отправок.
2. **Слишком длинный таймаут:**
  - длительные простои при потере пакетов (ожидание несуществующего ACK);
  - увеличение латентности (задержек) в передаче данных;
  - неэффективное использование канала.
3. **Оптимальный таймаут:**
  - рассчитывается адаптивно на основе истории передачи: усредняется время оборота сегментов (RTT — round-trip time) с 
учётом весовых коэффициентов;
  - учитывается дисперсия RTT для сетей с нестабильной задержкой;
  - коэффициент умножения среднего RTT обычно >2 для запаса.

**Итог:** баланс между размером окна и величиной таймаута критически важен для максимальной эффективности TCP — быстрой,
надёжной и без перегрузок передачи данных.

---

## 37. Может ли работать маршрутизатор, не имея таблицы маршрутизации? </br> Варианты ответов: </br> а) может, если выполняется маршрутизация от источника; </br> б) нет, это невозможно; </br> в) может, если выполняется лавинная маршрутизация; </br> г) может, если в маршрутизаторе задан маршрут по умолчанию.

Ответ а), в)

**а) Может, если выполняется маршрутизация от источника (source routing)**
- При таком подходе **путь пакета задаётся не маршрутизатором, а отправителем** (источником).
- В заголовке IP‑пакета указывается **полный список маршрутизаторов**, через которые должен пройти пакет.
- Маршрутизатор просто следует этим указаниям — ему **не нужна таблица маршрутизации** для принятия решения.
- Пример: опция *Strict Source and Record Route* в IPv4.

**в) Может, если выполняется лавинная маршрутизация (flooding)**
- Пакет **рассылается сразу во все доступные интерфейсы** (кроме того, откуда он пришёл).
- Каждый маршрутизатор повторяет эту операцию.
- В итоге пакет достигает адресата (если сеть связная), но **без анализа таблиц маршрутизации**.
- Метод неэффективен (создаёт избыточный трафик), но технически работает.
- Используется, например, на этапе изучения топологии в некоторых протоколах.

### Почему не остальные варианты

**б) Нет, это невозможно** — неверно, так как есть случаи (см. выше), когда маршрутизатор может работать без таблицы.

**г) Может, если в маршрутизаторе задан маршрут по умолчанию** — неверно.
- Маршрут по умолчанию (**0.0.0.0/0**) — это **запись в таблице маршрутизации**.
- Если таблицы нет, то и маршрута по умолчанию в ней быть не может.
- Для работы с маршрутом по умолчанию таблица **обязательна** — маршрутизатор сверяется с ней, чтобы выбрать этот маршрут,
если нет более точного совпадения.

---

## 38. К какому типу относится протокол OSPF? </br> Варианты ответов: </br> а) протокол маршрутизации; </br> б) протокол, основанный на алгоритме состояния связей; </br> в) адаптивный протокол; </br> г) централизованный; </br> д) дистанционно-векторный; </br> е) внутренний шлюзовый протокол.

Ответ а), б), в), е)

**а) Протокол маршрутизации**  
OSPF (Open Shortest Path First) — это **протокол динамической маршрутизации**, который помогает маршрутизаторам обмениваться
информацией о сетях и выбирать оптимальные пути для передачи данных.

**б) Протокол, основанный на алгоритме состояния связей (link‑state)**  
OSPF использует **алгоритм состояния связей**:
* каждый маршрутизатор изучает состояние своих соседей и связей с ними;
* строит карту всей сети (топологию);
* на основе этой карты рассчитывает кратчайшие пути с помощью алгоритма Дейкстры.

**в) Адаптивный протокол**  
OSPF **автоматически адаптируется** к изменениям в сети:
* если канал выходит из строя или меняется его стоимость (метрика), маршрутизаторы обновляют свои базы данных;
* перерассчитывают маршруты и распространяют обновления только о произошедших изменениях;
* сеть быстро восстанавливается после сбоев.

**е) Внутренний шлюзовый протокол (Interior Gateway Protocol, IGP)**  
OSPF предназначен для работы **внутри автономной системы (AS)** — например, в сети одной компании или провайдера. Он не 
используется для маршрутизации между разными AS (для этого служат EGP, например BGP).

### Почему не остальные варианты
**г) Централизованный** — неверно.  
OSPF — **децентрализованный** протокол: каждый маршрутизатор самостоятельно строит топологию и рассчитывает маршруты. Нет
единого управляющего узла.

**д) Дистанционно‑векторный** — неверно.  
Это характеристика других протоколов (например, RIP). Дистанционно‑векторные протоколы передают векторы расстояний (количество переходов)
до сетей. OSPF же основан на состоянии связей и передаёт информацию о топологии сети, а не просто о расстояниях.

---

## 39. Какие параметры сети учитывают метрики, поддерживаемые протоколом OSPF? </br> Варианты ответов: </br> а) пропускная способность; </br> б) время передачи; </br> в) надёжность каналов связи; </br> г) количество хопов.

Ответ а), в), г)

**а) Пропускная способность (bandwidth)**  
Это **основной параметр** в OSPF. Метрика рассчитывается как:

Cost = 10^8 / Bandwidth (бит/с)

Чем выше пропускная способность канала, тем ниже стоимость маршрута. Например:
* 10 Мбит/с → cost = 10;
* 100 Мбит/с → cost = 1;
* 1 Гбит/с → cost = 1.

**в) Надёжность каналов связи (reliability)**  
OSPF может учитывать **вероятность ошибок или потерь** на канале. Если интерфейс часто выдаёт ошибки, его стоимость может
быть повышена — маршрут через него станет менее предпочтительным. Надёжность обычно оценивается по статистике ошибок на интерфейсе.

**г) Количество хопов (hop count)**  
Хотя OSPF **не использует хопы (переход пакета через сетевое устройство) как единственный критерий** (в отличие от RIP), он косвенно учитывает их при построении 
дерева кратчайших путей. При равной стоимости каналов (cost) алгоритм может выбрать маршрут с меньшим числом переходов.
Однако это вторичный фактор — приоритет отдаётся пропускной способности и другим параметрам.


### Почему не вариант б) время передачи (delay)
**Время передачи (задержка, delay)** **не входит в стандартную метрику OSPF**. Протокол фокусируется на:
* пропускной способности;
* надёжности;
* нагрузке (в расширенных реализациях).

Задержка может учитываться в других протоколах (например, EIGRP) или настраиваться вручную через расширенные механизмы OSPF,
но **по умолчанию не используется** для расчёта стоимости маршрута.

---

## 40. Поясните, какие недостатки традиционной маршрутизации привели к созданию SDN (выберите вариант ответа): </br> а) негибкая процедура продвижения трафика на основе единственного поля — адреса назначения; </br> б) децентрализованные протоколы построения таблиц маршрутизации медленно реагируют на изменения топологии сети; </br> в) децентрализованные протоколы построения таблиц маршрутизации позволяют находить только квази-оптимальные маршруты; </br> г) для агрегированных потоков на интернет-магистралях необходима гибкая и адаптивная обработка на основе логического разделения трафика на отдельные потоки; </br> д) нестандартный командный язык конфигурирования сетевых устройств препятствует унификации управления этими устройствами.

Ответ а), б), в), д)

**а) Негибкая процедура продвижения трафика на основе единственного поля — адреса назначения**

Традиционная маршрутизация принимает решение **только по IP‑адресу назначения**. Это ограничивает возможности:
* нельзя управлять трафиком по приложениям, портам, протоколам или приоритетам;
* невозможно гибко разделять потоки или задавать разные политики для разных типов трафика;
* все пакеты одного адреса идут по одному маршруту, даже если есть более эффективные варианты.

**б) Децентрализованные протоколы построения таблиц маршрутизации медленно реагируют на изменения топологии сети**

В традиционной модели каждый маршрутизатор:
* самостоятельно строит таблицу маршрутизации;
* обменивается обновлениями с соседями (RIP, OSPF, BGP);
* обновляет маршруты **итеративно** — изменения распространяются постепенно.

Это приводит к:
* задержкам в пересчёте маршрутов при сбоях;
* временным «петлям маршрутизации»;
* нестабильности в период конвергенции.

**в) Децентрализованные протоколы построения таблиц маршрутизации позволяют находить только квази‑оптимальные маршруты**

Из‑за децентрализованности:
* маршрутизаторы имеют **неполное представление** о всей сети;
* протоколы выбирают маршрут «локально лучший», а не глобально оптимальный;
* не учитываются глобальные параметры: загрузка каналов, задержки, приоритеты потоков;
* трафик может идти неоптимальным путём, создавая перегрузки на одних участках и простаивание на других.

**д) Нестандартный командный язык конфигурирования сетевых устройств препятствует унификации управления этими устройствами**

У разных вендоров (Cisco, Juniper, Huawei и др.):
* свои CLI‑команды и синтаксис;
* разная логика настройки функций;
* несовместимые API или их отсутствие.

Последствия:
* сложно автоматизировать управление;
* требуется обучение под каждую платформу;
* затруднена централизованная оркестрация;
* выше риск ошибок из‑за ручных операций.

### Почему не вариант г)

**г) Для агрегированных потоков на интернет‑магистралях необходима гибкая и адаптивная обработка на основе логического 
разделения трафика на отдельные потоки**

Этот пункт **не является недостатком традиционной маршрутизации**, а скорее описывает потребность, которую SDN помогает удовлетворить.

Ключевые моменты:
* традиционная маршрутизация справляется с агрегированным трафиком на магистралях (использует BGP, MPLS);
* проблема не в самой агрегации, а в **недостаточной гибкости и централизации** управления;
* SDN даёт инструменты для разделения потоков и гибкой обработки, но исходная задача магистральной маршрутизации не была
принципиально невыполнимой — она была **недостаточно управляемой и адаптивной**.

---